// Copyright 2017 Capsule8, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sensor

import (
	"fmt"
	"reflect"
	"sync"
	"unicode"

	"github.com/capsule8/capsule8/pkg/expression"
	"github.com/capsule8/capsule8/pkg/sys/perf"

	"github.com/gobwas/glob"
	"github.com/golang/glog"

	"golang.org/x/sys/unix"
)

// ContainerEventTypes defines the field types that can be used with filters on
// container telemetry events.
var ContainerEventTypes = expression.FieldTypeMap{
	"name":             expression.ValueTypeString,
	"image_id":         expression.ValueTypeString,
	"image_name":       expression.ValueTypeString,
	"host_pid":         expression.ValueTypeSignedInt32,
	"exit_code":        expression.ValueTypeSignedInt32,
	"exit_status":      expression.ValueTypeUnsignedInt32,
	"exit_signal":      expression.ValueTypeUnsignedInt32,
	"exit_core_dumped": expression.ValueTypeBool,
}

// ContainerCreatedTelemetryEvent is a telemetry event generated by the
// container event source when a container is created.
type ContainerCreatedTelemetryEvent struct {
	TelemetryEventData
}

// CommonTelemetryEventData returns the telemtry event data common to all
// telemetry events for a chargen telemetry event.
func (e ContainerCreatedTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// ContainerDestroyedTelemetryEvent is a telemetry event generated by the
// container event source when a container is destroyed.
type ContainerDestroyedTelemetryEvent struct {
	TelemetryEventData
}

// CommonTelemetryEventData returns the telemtry event data common to all
// telemetry events for a chargen telemetry event.
func (e ContainerDestroyedTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// ContainerExitedTelemetryEvent is a telemetry event generated by the
// container event source when a container has exited.
type ContainerExitedTelemetryEvent struct {
	TelemetryEventData
}

// CommonTelemetryEventData returns the telemtry event data common to all
// telemetry events for a chargen telemetry event.
func (e ContainerExitedTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// ContainerRunningTelemetryEvent is a telemetry event generated by the
// container event source when a container starts running.
type ContainerRunningTelemetryEvent struct {
	TelemetryEventData
}

// CommonTelemetryEventData returns the telemtry event data common to all
// telemetry events for a chargen telemetry event.
func (e ContainerRunningTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// ContainerUpdatedTelemetryEvent is a telemetry event generated by the
// container event source when container information has been updated.ContainerUpdatedTelemetryEvent}
type ContainerUpdatedTelemetryEvent struct {
	TelemetryEventData
}

// CommonTelemetryEventData returns the telemtry event data common to all
// telemetry events for a chargen telemetry event.
func (e ContainerUpdatedTelemetryEvent) CommonTelemetryEventData() TelemetryEventData {
	return e.TelemetryEventData
}

// ContainerCache is a cache of container information
type ContainerCache struct {
	sync.Mutex
	cache map[string]*ContainerInfo

	sensor *Sensor

	// These are external event IDs registered with the sensor's event
	// monitor instance. The cache will enqueue these events as appropriate
	// as the cache is updated.
	ContainerCreatedEventID   uint64
	ContainerRunningEventID   uint64
	ContainerExitedEventID    uint64
	ContainerDestroyedEventID uint64
	ContainerUpdatedEventID   uint64
}

// ContainerState represents the state of a container (created, running, etc.)
type ContainerState uint

const (
	// ContainerStateUnknown indicates that the container is in an unknown
	// state.
	ContainerStateUnknown ContainerState = iota

	// ContainerStateCreated indicates the container exists, but is not
	// running.
	ContainerStateCreated

	// ContainerStatePaused indicates the container is paused.
	ContainerStatePaused

	// ContainerStateRunning indicates the container is running.
	ContainerStateRunning

	// ContainerStateRestarting indicates the container is in the process
	// of restarting.
	ContainerStateRestarting

	// ContainerStateExited indicates the container has exited.
	ContainerStateExited

	// ContainerStateRemoving indicates the container is being removed.
	ContainerStateRemoving
)

// ContainerStateNames is a mapping of container states to printable names.
var ContainerStateNames = map[ContainerState]string{
	ContainerStateCreated:    "created",
	ContainerStateRestarting: "restarting",
	ContainerStateRunning:    "running",
	ContainerStateRemoving:   "removing",
	ContainerStatePaused:     "paused",
	ContainerStateExited:     "exited",
}

// ContainerRuntime represents the runtime used to manager a container
type ContainerRuntime uint

const (
	// ContainerRuntimeUnknown means the container runtime managing the
	// container is unknown. Information about the container comes from
	// runc, the kernel, or other generic sources.
	ContainerRuntimeUnknown ContainerRuntime = iota

	// ContainerRuntimeDocker means the container is managed by Docker.
	ContainerRuntimeDocker
)

// ContainerInfo records interesting information known about a container.
type ContainerInfo struct {
	ID        string
	Name      string
	ImageID   string
	ImageName string

	Pid      int
	ExitCode int

	Runtime ContainerRuntime
	State   ContainerState

	JSONConfig string
	OCIConfig  string
}

// NewContainerCache creates a new container cache.
func NewContainerCache(sensor *Sensor) *ContainerCache {
	cache := &ContainerCache{
		cache:  make(map[string]*ContainerInfo),
		sensor: sensor,
	}

	var err error
	cache.ContainerCreatedEventID, err = sensor.Monitor.RegisterExternalEvent(
		"CONTAINER_CREATED", cache.decodeContainerCreatedEvent)
	if err != nil {
		glog.Fatalf("Failed to register external event: %s", err)
	}

	cache.ContainerRunningEventID, err = sensor.Monitor.RegisterExternalEvent(
		"CONTAINER_RUNNING", cache.decodeContainerRunningEvent)
	if err != nil {
		glog.Fatalf("Failed to register external event: %s", err)
	}

	cache.ContainerExitedEventID, err = sensor.Monitor.RegisterExternalEvent(
		"CONTAINER_EXITED", cache.decodeContainerExitedEvent)
	if err != nil {
		glog.Fatalf("Failed to register external event: %s", err)
	}

	cache.ContainerDestroyedEventID, err = sensor.Monitor.RegisterExternalEvent(
		"CONTAINER_DESTROYED", cache.decodeContainerDestroyedEvent)
	if err != nil {
		glog.Fatalf("Failed to register external event: %s", err)
	}

	cache.ContainerUpdatedEventID, err = sensor.Monitor.RegisterExternalEvent(
		"CONTAINER_UPDATED", cache.decodeContainerUpdatedEvent)
	if err != nil {
		glog.Fatalf("Failed to register extern event: %s", err)
	}

	return cache
}

// DeleteContainer removes a container from the cache.
func (cc *ContainerCache) DeleteContainer(
	containerID string,
	runtime ContainerRuntime,
	sampleID perf.SampleID,
) {
	cc.Lock()
	info, ok := cc.cache[containerID]
	if ok {
		if runtime == info.Runtime {
			delete(cc.cache, containerID)
		} else {
			ok = false
		}
	}
	cc.Unlock()

	if ok {
		glog.V(2).Infof("Sending CONTAINER_DESTROYED for %s", info.ID)
		cc.enqueueContainerEvent(cc.ContainerDestroyedEventID,
			sampleID, info)
	}
}

func (cc *ContainerCache) newContainerInfo(containerID string) *ContainerInfo {
	return &ContainerInfo{
		ID:      containerID,
		Runtime: ContainerRuntimeUnknown,
	}
}

// LookupContainer searches the cache for a container by ID and returns any
// information found, optionally creating a cache entry if there is one does
// not already exist.
func (cc *ContainerCache) LookupContainer(containerID string, create bool) *ContainerInfo {
	cc.Lock()
	defer cc.Unlock()

	info := cc.cache[containerID]
	if info == nil && create {
		info = cc.newContainerInfo(containerID)
		cc.cache[containerID] = info
	}

	return info
}

func (cc *ContainerCache) enqueueContainerEvent(
	eventID uint64,
	sampleID perf.SampleID,
	info *ContainerInfo,
) error {
	ws := unix.WaitStatus(info.ExitCode)
	data := map[string]interface{}{
		"__container__":    *info,
		"container_id":     info.ID,
		"name":             info.Name,
		"image_id":         info.ImageID,
		"image_name":       info.ImageName,
		"host_pid":         int32(info.Pid),
		"exit_code":        int32(info.ExitCode),
		"exit_status":      uint32(0),
		"exit_signal":      uint32(0),
		"exit_core_dumped": ws.CoreDump(),
	}

	if ws.Exited() {
		data["exit_status"] = uint32(ws.ExitStatus())
	}
	if ws.Signaled() {
		data["exit_signal"] = uint32(ws.Signal())
	}

	return cc.sensor.Monitor.EnqueueExternalSample(eventID, sampleID, data)
}

func (cc *ContainerCache) decodeContainerCreatedEvent(
	sample *perf.SampleRecord,
	data perf.TraceEventSampleData,
) (interface{}, error) {
	var e ContainerCreatedTelemetryEvent
	if !e.InitWithSample(cc.sensor, sample, data) {
		return nil, nil
	}
	e.TelemetryEventData.Container = data["__container__"].(ContainerInfo)
	return e, nil
}

func (cc *ContainerCache) decodeContainerRunningEvent(
	sample *perf.SampleRecord,
	data perf.TraceEventSampleData,
) (interface{}, error) {
	var e ContainerRunningTelemetryEvent
	if !e.InitWithSample(cc.sensor, sample, data) {
		return nil, nil
	}
	e.TelemetryEventData.Container = data["__container__"].(ContainerInfo)
	return e, nil
}

func (cc *ContainerCache) decodeContainerExitedEvent(
	sample *perf.SampleRecord,
	data perf.TraceEventSampleData,
) (interface{}, error) {
	var e ContainerExitedTelemetryEvent
	if !e.InitWithSample(cc.sensor, sample, data) {
		return nil, nil
	}
	e.TelemetryEventData.Container = data["__container__"].(ContainerInfo)
	return e, nil
}

func (cc *ContainerCache) decodeContainerDestroyedEvent(
	sample *perf.SampleRecord,
	data perf.TraceEventSampleData,
) (interface{}, error) {
	var e ContainerDestroyedTelemetryEvent
	if !e.InitWithSample(cc.sensor, sample, data) {
		return nil, nil
	}
	e.TelemetryEventData.Container = data["__container__"].(ContainerInfo)
	return e, nil
}

func (cc *ContainerCache) decodeContainerUpdatedEvent(
	sample *perf.SampleRecord,
	data perf.TraceEventSampleData,
) (interface{}, error) {
	var e ContainerUpdatedTelemetryEvent
	if !e.InitWithSample(cc.sensor, sample, data) {
		return nil, nil
	}
	e.TelemetryEventData.Container = data["__container__"].(ContainerInfo)
	return e, nil
}

// Update updates the data cached for a container with new information. Some
// new information may trigger telemetry events to fire.
func (info *ContainerInfo) Update(
	cache *ContainerCache,
	runtime ContainerRuntime,
	sampleID perf.SampleID,
	data map[string]interface{},
) {
	if info.Runtime == ContainerRuntimeUnknown {
		info.Runtime = runtime
	}

	oldState := info.State
	dataChanged := false

	s := reflect.ValueOf(info).Elem()
	t := s.Type()
	for i := t.NumField() - 1; i >= 0; i-- {
		f := t.Field(i)
		if !unicode.IsUpper(rune(f.Name[0])) {
			continue
		}
		v, ok := data[f.Name]
		if !ok {
			continue
		}
		if !reflect.TypeOf(v).AssignableTo(f.Type) {
			glog.Fatalf("Cannot assign %v to %s %s",
				v, f.Name, f.Type)
		}

		if s.Field(i).Interface() != v {
			if f.Name != "State" {
				dataChanged = true
			} else if info.Runtime != runtime {
				// Only allow state changes from the runtime
				// known to be managing the container.
				continue
			}
			s.Field(i).Set(reflect.ValueOf(v))
		}
	}

	if info.State != oldState {
		if oldState < ContainerStateCreated {
			glog.V(2).Infof("Sending CONTAINER_CREATED for %s", info.ID)
			cache.enqueueContainerEvent(
				cache.ContainerCreatedEventID, sampleID, info)
		}
		if oldState < ContainerStateRunning &&
			info.State >= ContainerStateRunning {
			glog.V(2).Infof("Sending CONTAINER_RUNNING for %s", info.ID)
			cache.enqueueContainerEvent(
				cache.ContainerRunningEventID, sampleID, info)
		}
		if oldState < ContainerStateRestarting &&
			info.State >= ContainerStateRestarting {
			glog.V(2).Infof("Sending CONTAINER_EXITED for %s", info.ID)
			cache.enqueueContainerEvent(
				cache.ContainerExitedEventID, sampleID, info)
		}
	} else if dataChanged {
		glog.V(2).Infof("Sending CONTAINER_UPDATED for %s", info.ID)
		cache.enqueueContainerEvent(
			cache.ContainerUpdatedEventID, sampleID, info)
	}
}

func (s *Subscription) registerContainerEventFilter(
	eventID uint64,
	expr *expression.Expression,
) {
	if _, err := s.addEventSink(eventID, expr, ContainerEventTypes); err != nil {
		s.logStatus(
			fmt.Sprintf("Invalid container filter expression: %v", err))
	}
}

// RegisterContainerCreatedEventFilter registers a container created event
// filter with a subscription.
func (s *Subscription) RegisterContainerCreatedEventFilter(expr *expression.Expression) {
	s.registerContainerEventFilter(
		s.sensor.ContainerCache.ContainerCreatedEventID,
		expr)
}

// RegisterContainerRunningEventFilter registers a container running event
// filter with a subscription.
func (s *Subscription) RegisterContainerRunningEventFilter(expr *expression.Expression) {
	s.registerContainerEventFilter(
		s.sensor.ContainerCache.ContainerRunningEventID,
		expr)
}

// RegisterContainerExitedEventFilter registers a container exited event
// filter with a subscription.
func (s *Subscription) RegisterContainerExitedEventFilter(expr *expression.Expression) {
	s.registerContainerEventFilter(
		s.sensor.ContainerCache.ContainerExitedEventID,
		expr)
}

// RegisterContainerDestroyedEventFilter registers a container destroyed event
// filter with a subscription.
func (s *Subscription) RegisterContainerDestroyedEventFilter(expr *expression.Expression) {
	s.registerContainerEventFilter(
		s.sensor.ContainerCache.ContainerDestroyedEventID,
		expr)
}

// RegisterContainerUpdatedEventFilter registers a container updated event
// filter with a subscription.
func (s *Subscription) RegisterContainerUpdatedEventFilter(expr *expression.Expression) {
	s.registerContainerEventFilter(
		s.sensor.ContainerCache.ContainerUpdatedEventID,
		expr)
}

///////////////////////////////////////////////////////////////////////////////

// NewContainerFilter creates a new container filter
func NewContainerFilter() *ContainerFilter {
	return &ContainerFilter{}
}

// ContainerFilter is a filter that is used to filter telemetry events based
// on container ID, container name, image ID, or image name.
type ContainerFilter struct {
	containerIDs   map[string]struct{}
	containerNames map[string]struct{}
	imageIDs       map[string]struct{}
	imageGlobs     map[string]glob.Glob
}

// Len returns the number of filters that are active within a ContainerFilter.
func (c *ContainerFilter) Len() int {
	return len(c.containerIDs) + len(c.containerNames) +
		len(c.imageIDs) + len(c.imageGlobs)
}

// AddContainerID adds a container ID to a container filter.
func (c *ContainerFilter) AddContainerID(cid string) {
	if len(cid) > 0 {
		if c.containerIDs == nil {
			c.containerIDs = make(map[string]struct{})
		}
		c.containerIDs[cid] = struct{}{}
	}
}

// AddContainerName adds a container name to a container filter.
func (c *ContainerFilter) AddContainerName(cname string) {
	if len(cname) > 0 {
		if c.containerNames == nil {
			c.containerNames = make(map[string]struct{})
		}
		c.containerNames[cname] = struct{}{}
	}
}

// AddImageID adds an image ID to a container filter.
func (c *ContainerFilter) AddImageID(iid string) {
	if len(iid) > 0 {
		if c.imageIDs == nil {
			c.imageIDs = make(map[string]struct{})
		}
		c.imageIDs[iid] = struct{}{}
	}
}

// AddImageName adds and image name to a container filter.
func (c *ContainerFilter) AddImageName(iname string) error {
	if len(iname) > 0 {
		if c.imageGlobs == nil {
			c.imageGlobs = make(map[string]glob.Glob)
		} else if _, ok := c.imageGlobs[iname]; ok {
			return nil
		}
		if g, err := glob.Compile(iname, '/'); err == nil {
			c.imageGlobs[iname] = g
		} else {
			return err
		}
	}
	return nil
}

// Match evaluates a container filter for a ContainerInfo struct and determines
// whether it matches the criteria set forth by the filter.
func (c *ContainerFilter) Match(info ContainerInfo) bool {
	if c == nil {
		return true
	}
	if len(info.ID) == 0 {
		return false
	}

	// Fast path: Check if containerID is in containerIDs map
	if _, ok := c.containerIDs[info.ID]; ok {
		return true
	}

	// Slow path: Check if other identifiers are in maps. If they are, add
	// the containerId to containerIds map to take fast path next time.
	if _, ok := c.containerNames[info.Name]; ok {
		c.AddContainerID(info.ID)
		return true
	}
	if _, ok := c.imageIDs[info.ImageID]; ok {
		c.AddContainerID(info.ID)
		return true
	}
	if c.imageGlobs != nil && info.ImageName != "" {
		for _, g := range c.imageGlobs {
			if g.Match(info.ImageName) {
				c.AddContainerID(info.ID)
				return true
			}
		}
	}

	return false
}
